# Telegram Auction Service

Сервис для создания мульти-раундовых аукционов на цифровые товары.<br>
Tech Stack: `TypeScript`, `Node.js`, `Express`, `Mongodb`, `Redis`.

## Flows
### Auction Creation Flow
Для создания Аукциона необходимо указать следующие параметры:
- Название Аукциона (опционально)
- Название цифровой товара, выставляемого на Аукцион
- Минимальная ставка
- Количество победителей
- Количество раундов
- Продолжительность первого раунда (опционально)
- Продолжительность остальных раундов
- Дата и время начала Аукциона<br>

Что просчитывается автоматически, после заполнения вышеперечисленных параметров:
- ID Аукциона
- Количество победителей за раунд
- Планируемые дата и время окончания Аукциона
- Статус `DRAFT` Аукциона
- Количество оставшихся цифровых товаров
- Текущий раунд<br>

Также, если мы говорим про экосистему Telegram, то в таком случае мы можем получить initData.user.id или initData.user.username для привязки Аукциона к пользователю. ID пользователя будем передавать в http заголовке X-User-Id

### Auction Edit Flow
Редактировать можно те же поля, которые присутствуют в форме создания Аукциона. Присутствует проверка на `status == DRAFT` и `creator_id`, чтобы избежать `idor` уязвимости.

### Auction Join Flow
При открытии старницы "прямого эфира" Аукциона открывается веб-сокет и показывается текущее состояние Аукциона. Если он еще не в статусе `LIVE`, появляется обратный отсчет до начала Аукциона.

### Auction Bid Flow 
Участник делает ставку и видит, какое место на текущий момент он занимает. После ставки он может добавить валюту к текущей ставке, если выбыл из выигрышного топа. В тг аукционах в первом раунде действует правило (anti-sniping), в течение последних 30 секунд участники из топ3 могут перебивать ставку, чтобы занять 1 место. Если кто-то перебил, то добавляется еще 30 секунд.<br>

Если в раунде никто не сделал ставку, просто переходим на следующий, число предметов не уменьшается.<br>

Если ставка не была выигрышной в раунде, она переносится на следующий. Если в последнем раунде она не выиграла, средства возвращаются на баланс пользователя.<br>

С течением раундов, минимальная ставка увеличивается.<br>

Каждая ставка имеет ключ идемпотентости для избежания дублирования ставок от пользователей.

### Auction Bots Flow
Для демонстрации работы аукциона была создана возможность запуска активности от ботов в каждом раунде аукциона. Панель управления ботами расположена в нижней части страницы прямого эфира аукциона. 

## Архитектура

### Общая структура

Сервис построен на основе многослойной архитектуры с разделением ответственности между компонентами:

```
┌─────────────────────────────────────────────────────────┐
│                    HTTP/WebSocket Layer                 │
│  (Express API Routes + WebSocket Server)                │
└────────────────────┬────────────────────────────────────┘
                     │
┌────────────────────▼────────────────────────────────────┐
│                   Service Layer                         │
│  ┌──────────────┐ ┌──────────┐ ┌──────────────┐         │
│  │ Auctions     │ │ Bids     │ │ Users        │         │
│  └──────────────┘ └──────────┘ └──────────────┘         │
│  ┌──────────────┐ ┌──────────┐ ┌──────────────┐         │
│  │ Lifecycle    │ │ Bots     │ │ Deliveries   │         │
│  └──────────────┘ └──────────┘ └──────────────┘         │
└────────────────────┬────────────────────────────────────┘
                     │
┌────────────────────▼────────────────────────────────────┐
│              Data & Cache Layer                         │
│  ┌──────────────┐          ┌──────────────┐             │
│  │   MongoDB    │          │    Redis     │             │
│  │  (Storage)   │          │   (Cache +   │             │
│  │              │          │  Rate Limit) │             │
│  └──────────────┘          └──────────────┘             │
└─────────────────────────────────────────────────────────┘
```

### Компоненты системы

#### 1. **API Layer** (`src/routes/api.ts`)
- RESTful API endpoints для управления аукционами
- Обработка HTTP-запросов с валидацией
- Rate limiting через Redis
- Аутентификация через заголовок `X-User-Id`

**Основные endpoints:**
- `GET /api/auctions` - список аукционов
- `POST /api/auctions` - создание аукциона
- `PUT /api/auctions/:id` - обновление аукциона
- `POST /api/auctions/:id/bids` - создание ставки
- `GET /api/auctions/:id` - получение аукциона
- `POST /api/auctions/:id/release` - публикация аукциона

#### 2. **Service Layer** (`src/services/`)

**`auction-lifecycle.ts`** - Менеджер жизненного цикла аукционов
- Event-driven архитектура на основе MongoDB Change Streams
- Управление таймерами раундов
- Обработка переходов между статусами (DRAFT → RELEASED → LIVE → FINISHED)
- Anti-sniping механизм (автоматическое продление раунда при ставках топ-3)
- Фоновая обработка переноса ставок между раундами через Redis Queue
- Обработка доставок выигрышей

**`auctions.ts`** - Бизнес-логика аукционов
- Создание и валидация аукционов
- Расчет параметров (winners_per_round, planned_end_datetime)
- Обновление статусов

**`bids.ts`** - Управление ставками
- Создание ставок с проверкой баланса
- Идемпотентность через `idempotency_key`
- Расчет позиций участников
- Перенос неудачных ставок на следующий раунд
- Возврат средств проигравшим в последнем раунде

**`users.ts`** - Управление пользователями
- Создание пользователей по Telegram ID
- Управление балансом
- Автоматическое создание при первой ставке

**`websocket.ts`** - WebSocket сервер для real-time обновлений
- Подписка на обновления аукциона
- Broadcast изменений состояния
- Оптимизация через дедупликацию обновлений
- Периодическое обновление таймеров

**`bots.ts`** - Симуляция активности ботов
- Регистрация ботов для аукциона
- Автоматические ставки в каждом раунде
- Настройка параметров активности

**`deliveries.ts`** - Управление доставками
- Создание записей о выигрышах
- Обработка статусов доставки
- Статистика по доставкам

**`cache.ts`** - Кэширование через Redis
- Кэш топ-ставок
- Кэш данных аукциона
- Кэш позиций пользователей
- Инвалидация кэша при изменениях

#### 3. **Data Layer**

**MongoDB** (`src/storage/mongo.ts`) - Основное хранилище данных

**Модели данных:**
- **Auction** - информация об аукционе
  - Статусы: `DRAFT`, `RELEASED`, `LIVE`, `FINISHED`, `DELETED`
  - Индексы: `status`, `creator_id`, `status + start_datetime`
  
- **Bid** - ставки участников
  - Индексы: `auction_id + round_id + amount`, `idempotency_key` (unique)
  
- **Round** - информация о раундах
  - Индексы: `auction_id + idx` (unique)
  
- **User** - пользователи
  - Индексы: `tg_id` (unique), `username`
  
- **Deliveries** - доставки выигрышей
  - Статусы: `PENDING`, `DELIVERED`, `FAILED`
  - Индексы: `auction_id`, `winner_user_id`, `status`

**Redis** - Кэширование и очереди
- Кэширование часто запрашиваемых данных (топ-ставки, аукционы)
- Rate limiting для API endpoints
- Очередь для асинхронной обработки переноса ставок (`bid_transfer_queue`)
- TTL для автоматической инвалидации кэша

#### 4. **Middleware** (`src/middleware/rateLimit.ts`)
- Rate limiting на основе Redis
- Разные лимиты для разных типов запросов
- Отключение для load testing

### Потоки данных

#### Обработка ставки
```
Client → API → Bids Service → MongoDB
                ↓
         Redis Cache Update
                ↓
         WebSocket Broadcast
                ↓
    Lifecycle Manager (если топ-3)
```

#### Жизненный цикл аукциона
```
MongoDB Change Stream → Lifecycle Manager
                            ↓
                    Timer Management
                            ↓
                    Round Transitions
                            ↓
                    Bid Transfer Queue (Redis)
                            ↓
                    Delivery Processing
```

#### Real-time обновления
```
State Change → WebSocket Service
                    ↓
            Subscription Map
                    ↓
            Broadcast to Clients
```

### Особенности архитектуры

1. **Event-Driven подход**
   - Использование MongoDB Change Streams для отслеживания изменений
   - Асинхронная обработка через Redis Queue
   - Минимизация polling через event-driven обновления

2. **Масштабируемость**
   - Stateless API серверы (можно горизонтально масштабировать)
   - Redis для распределенного кэширования и rate limiting
   - Оптимизированные индексы MongoDB

3. **Надежность**
   - Идемпотентность операций (idempotency_key)
   - Graceful shutdown с корректным завершением соединений
   - Обработка ошибок и таймаутов

4. **Производительность**
   - Многоуровневое кэширование (Redis)
   - Оптимизация WebSocket обновлений (дедупликация)
   - Индексы для быстрых запросов

5. **Безопасность**
   - Rate limiting для защиты от DDoS
   - Валидация входных данных
   - Проверка прав доступа (creator_id)
   - Защита от IDOR уязвимостей


## Testing
### Prod
- [Web](https://tagwaiter.ru)
- [Mini App](https://t.me/CryptoAuctionDemoBot)

### Local
Для запуска локально необходимо выполнить следующие команды
```bash
cp .env.example .env
docker-compose up -d
chmod +x .init-replica-set.sh
./init-replica-set.sh
npm i
npm run build
npm run dev
# goto http://localhost:3000/
```

### Load
```bash
npm i && npm run build
npm run dev
# после старта сервиса необходимо создать аукцион, сделать его релиз и дождаться LIVE статуса
# после можно запустить скрипт теста
npm run load-test
```
Пример вывода
```
=== Load Test Configuration ===
Base URL: http://localhost:3000
Number of users: 1000
Bids per user: 1
Concurrent bids: 100
Bid amount range (from config): 200 - 1000
Note: Actual bid range will be determined from auction parameters

✓ Rate limiter is disabled for load testing

===============================

✓ Server is healthy

Using existing LIVE auction: 6970c59445b778d5f5de551b
Using auction ID: 6970c59445b778d5f5de551b

Fetching auction data...
Auction parameters:
  Min bid: 100
  Effective bid range: 200 - 1000
  Rounds: 100
  Winners per round: 100

Creating users...
Created 1000/1000 users...
✓ Created 1000 users

Starting load test with 1000 total bids...

Progress: 1000/1000 (100.0%) - 1000 successful

=== Load Test Results ===
Total requests: 1000
Successful: 1000 (100.00%)
Failed: 0 (0.00%)

Requests per second: 117.05
Total time: 8.54s

Response times (ms):
  Average: 830.47
  Min: 111
  Max: 1374
  p50: 749
  p95: 1368
  p99: 1371
========================

Load test completed successfully
```

## Demo

[demo video link](https://drive.google.com/drive/folders/1neewyHGuzeYfQeevTvT3qNlISiY8R80M?usp=drive_link)
